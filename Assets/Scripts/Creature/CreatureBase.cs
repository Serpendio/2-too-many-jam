using UnityEngine;
using System;
using Tweens;
using UI;
using UnityEngine.Events;
using System.Collections;
using System.Collections.Generic;
using System.Net.Http.Headers;

namespace Creature
{
    public enum Team
    {
        Friendly,
        Hostile,
        DamagesAll
    }

    [HideInInspector] public enum StatusEffects
    {
        Poisoned,
        Burning,
        Frozen,
        Stunned,
        Greed,
        Slowed,
        Silenced,
        Bleeding,
        Cursed,
        Charmed, // most of these are generated by copilot, idk if we want them
        Enraged,
        Shielded,
        Invisible,
        DamageBuff,
        AttackSpeedBuff
    }

    [Serializable]
    public class StatusStruct
    {
        public StatusEffects effect;
        [Range(0f, 1f)] public float chance;
        public float duration;
        public float param2;
        public float param3;

        public StatusStruct(StatusEffects effect, float duration, float param2 = 0f, float param3 = 0f)
        {
            this.effect = effect;
            this.duration = duration;
            this.param2 = param2;
            this.param3 = param3;
        }
    }

    [RequireComponent(typeof(Animator))]
    [RequireComponent(typeof(SpriteRenderer))]
    [RequireComponent(typeof(Rigidbody2D))]
    public class CreatureBase : MonoBehaviour
    {
        private static readonly int XMove = Animator.StringToHash("xMove");
        private static readonly int YMove = Animator.StringToHash("yMove");
        private static readonly int Attack = Animator.StringToHash("Attack");
        private static readonly int Multiplier = Animator.StringToHash("multiplier");

        private static IDictionary<StatusEffects, Sprite> _statusSprites = new Dictionary<StatusEffects, Sprite>();
        private static HealthChangeIndicator _healthChangeIndicatorPrefab;
        
        [SerializeField] private Transform _statusParent;
        [HideInInspector] public UnityEvent OnDeath = new();

        protected Animator Anim;
        protected SpriteRenderer spriteRenderer;
        [HideInInspector] public Rigidbody2D Rb;

        [field: SerializeField] public float health { get; private set; }
        [field: SerializeField] public float maxHealth { get; private set; }

        [HideInInspector] public UnityEvent<float, float> OnHealthChanged = new();

        public Team Team;


        //----TO ADD A NEW Status:----//
        //*Add the name of the statusEffects to the StatusEffects enum
        //*Create a new private IEnumerator method with up to 3 parameters to house the statusEffects logic in
        //*Add the method to the statusCoroutines array in Start()

        //----TO CALL A Status----//
        //*Call CreatureBase.ApplyStatus(StatusEffects effects, float param1, float param2, float param3)

        //----TO CANCEL A Status PREMATURELY----//
        //*Call RemoveStatus(StatusEffects effects)

        public bool[] activeStatuses;
        //Helper-delegate, just used to pass more than one parameter to the coroutines :]
        //Default values provided in case coroutine need not take all 3 parameters
        public delegate IEnumerator MultiParamCoroutine(float param1=0, float param2=0, float param3=0);
        public MultiParamCoroutine[] statusCoroutines;
        
        protected virtual void Awake()
        {
            Core.Locator.CreatureManager.AddCreature(this);

            health = maxHealth;

            Anim = GetComponent<Animator>();
            spriteRenderer = GetComponent<SpriteRenderer>();
            Rb = GetComponent<Rigidbody2D>();
            
            if (!_healthChangeIndicatorPrefab) _healthChangeIndicatorPrefab = Resources.Load<HealthChangeIndicator>("Prefabs/HealthChangeIndicator");

            
            if (_statusSprites.Count == 0)
            {
                _statusSprites = new Dictionary<StatusEffects, Sprite>
                {
                    { StatusEffects.Poisoned, Resources.Load<Sprite>("Sprites/statusPoison") },
                    { StatusEffects.Burning, Resources.Load<Sprite>("Sprites/statusBurning") },
                    { StatusEffects.Frozen, Resources.Load<Sprite>("Sprites/statusFrozen") },
                    { StatusEffects.Stunned, Resources.Load<Sprite>("Sprites/statusStunned") },
                };
            }
        }

        protected virtual void Start()
        {
            SetHealth(maxHealth);
            activeStatuses = new bool[Enum.GetNames(typeof(StatusEffects)).Length];
            statusCoroutines = new MultiParamCoroutine[] {Poison};
        }

        protected IEnumerator Poison(float duration, float damagePerHit, float secondsBetweenPoisonHits)
        {
            //Run for specified number of seconds
            while (duration > 0 && activeStatuses[(int)StatusEffects.Poisoned])
            {
                //Apply poison effect
                health -= damagePerHit;
                duration -= secondsBetweenPoisonHits;
                
                yield return new WaitForSeconds(secondsBetweenPoisonHits);
            }
            yield break;
        }

        protected IEnumerator Burning(float duration, float damagePerSecond, float p3)
        {
            //Run for specified number of seconds
            while (duration > 0 && activeStatuses[(int)StatusEffects.Burning])
            {
                //Apply burn effect
                health -= damagePerSecond * Time.deltaTime;
                duration -= Time.deltaTime;
                yield return 0; // next frame
            }
            activeStatuses[(int)StatusEffects.Burning] = false;
            yield break;
        }

        protected IEnumerator Frozen(float duration, float p2, float p3)
        {
            //Run for specified number of seconds
            while (duration > 0 && activeStatuses[(int)StatusEffects.Frozen])
            {
                duration -= Time.deltaTime;
                yield return 0; // next frame
            }
            activeStatuses[(int)StatusEffects.Frozen] = false;
            yield break;
        }

        protected IEnumerator Stunned(float duration, float p2, float p3)
        {
            //Run for specified number of seconds
            while (duration > 0 && activeStatuses[(int)StatusEffects.Stunned])
            {
                duration -= Time.deltaTime;
                yield return 0; // next frame
            }
            activeStatuses[(int)StatusEffects.Stunned] = false;
            yield break;
        }

        public void SetHealth(float value, bool showIndicator = false)
        {
            var diff = value - health;
            
            health = Mathf.Clamp(value, 0, maxHealth);
            OnHealthChanged.Invoke(health, maxHealth);
            
            if (showIndicator && diff != 0)
            {
                var indicator = Instantiate(_healthChangeIndicatorPrefab, transform.position, Quaternion.identity);
                indicator.Change = diff;
            }
        }

        public void SetMaxHealth(float value, bool refill = false)
        {
            var diff = value - maxHealth;
            maxHealth = value;
            if (refill)
            {
                SetHealth(health + diff);
            }
            else
            {
                OnHealthChanged.Invoke(health, maxHealth);
            }
        }

        protected void UpdateMoveDir(Vector2 lookDir, bool isMoving)
        {
            Anim.SetFloat(Multiplier, Convert.ToInt32(isMoving));

            if (lookDir.sqrMagnitude == 0)
            {
                return;
            }

            if (lookDir.sqrMagnitude != 0)
            {
                spriteRenderer.flipX = lookDir.x < 0;
            }

            Anim.SetFloat(XMove, lookDir.x);
            Anim.SetFloat(YMove, lookDir.y);
        }

        protected virtual void TriggerAttackAnim()
        {
            Anim.SetTrigger(Attack);
        }

        public virtual void TakeDamage(float damage, Color? colourOverride = null)
        {
            SetHealth(Mathf.Clamp(health - damage, 0, maxHealth), showIndicator: true);
            
            if (health == 0)
            {
                Die();
                return;
            }
            
            colourOverride??= new Color(1f, 0.2f, 0.2f, 0.6667f);
            // tween flash sprite colour as red
            gameObject.AddTween(new SpriteRendererColorTween
            {
                from = Color.white,
                to = colourOverride,
                duration = 0.05f,
                easeType = EaseType.CubicInOut,
                usePingPong = true,
                onEnd = _ => spriteRenderer.color = Color.white,
            });
        }

        public virtual void ApplyStatus(StatusEffects effect, float duration, float param2 = 0f, float param3 = 0f) {
            if (activeStatuses[(int)effect])
            {
                RemoveStatus(effect);
            }
            activeStatuses[(int)effect] = true;

            Instantiate(new GameObject(effect.ToString()), _statusParent).AddComponent<SpriteRenderer>().sprite = _statusSprites[effect];

            StartCoroutine(statusCoroutines[(int)effect](duration, param2, param3));
        }

        //Prematurely end statusEffects
        public virtual void RemoveStatus(StatusEffects effect) {
            activeStatuses[(int)effect] = false;
            Instantiate(new GameObject(effect.ToString()), _statusParent).AddComponent<SpriteRenderer>().sprite = _statusSprites[effect];
            Destroy(_statusParent.Find(effect.ToString()).gameObject);
            StopCoroutine(statusCoroutines[(int)effect](0, 0, 0));
        }

        private void UpdateStatusVFX()
        {
            spriteRenderer.material.SetColorArray("_StatusColours", new []{Color.red, Color.green, Color.blue, Color.yellow, Color.magenta, Color.cyan, Color.white, Color.black, Color.grey, Color.clear, Color.grey, Color.grey, Color.grey, Color.grey, Color.grey});
        }

        public virtual void RefillHealth()
        {
            SetHealth(maxHealth);
        }

        protected virtual void Die()
        {
            OnDeath.Invoke();
            Destroy(gameObject);
        }

        [ContextMenu("Force Kill")]
        private void ForceKill()
        {
            SetHealth(0);
        }
    }
}